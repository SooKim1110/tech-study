# 2장. 테스트

테스트는 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 준다.

## 왜 테스트를 하는가?
- 테스트는 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업
- 새로운 기능이 기대대로 동작 + 기존 기능이 영향을 받지 않았는지 확인


## 단위 테스트
- 충분히 작은 하나의 관심에 집중해서 효율적으로 테스트
- 왜? 관심사의 분리. 테스트 수행 과정을 간단하게 & 오류 발생시 원인을 빨리 찾기 쉽게
- 일관된 결과: 통제할 수 없는 외부의 리소스에 의존하면 안되며, 테스트를 실행하는 순서를 바꿔도 동일 결과가 보장되어야한다.

=> Junit 각 테스트가 서로 영향을 주지 않고, 독립적으로 실행됨을 보장해주기 위해 매번 새로 테스트 클래스의 오브젝트를 만든다
=> 스프링이 제공하는 테스트 컨텍스트 프레임워크를 사용해 모든 테스트가 하나의 ApplicationContext를 공유하게 만들 수 있다
```
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {
    @Autowired
    private ApplicationContext context;
}
```

## 테스트 작성시 주의점
- 부정적인 케이스를 먼저 만들자. 성공하는 테스트만 골라서 만들지 말고, 예외상황까지 고려하자.

## TDD
테스트 코드를 먼저 만들고 테스트를 설공하게 해주는 코드를 작성하는 방식의 개발 방법
- 자연스럽게 단위 테스트를 만들 수 있다
- 코드를 만들고 테스트를 실행하는 사이 간격이 짧다

## Fixture
테스트를 수행하는데 필요한 정보나 오브젝트. 보통 여러 테스트에서 반복적으로 사용.
예) UserDaoTest에서의 dao나 User 오브젝트 

## DI와 테스트
### 왜 인터페이스를 두고 DI를 사용해야하나?
- 소프트웨어 개발에서 절대 바뀌지 않는 것은 없다. 변경이 필요할 때 수정에 들어가는 시간과 비용을 줄여준다.
- 기존 코드를 수정할 필요없이 부가 기능을 도입할 수 있다 (AOP)
- 테스트를 할 때 가능한 한 작은 단위의 대상에 테스트해야하고, DI는 테스트가 작은 단위의 대상에 독립적으로 만들어지고 실행되게 한다.

### DI를 이용한 테스트
- 스프링 컨테이너를 사용하지 않고, 테스트 코드에서 직접 오브젝트를 만들고 DI. 테스트 수행 속도가 빠르고 테스트가 간결.
- 복잡한 의존관계를 갖고 있는 오브젝트를 테스트 할 때는 테스트 전용 설정파일을 써서 스프링의 DI 이용
- 예외적인 의존관계를 강제로 구성해야할 때는 컨텍스트에서 DI 받은 오브젝트에 테스트 코드로 수동 DI (@DirtiesContext)

## 학습 테스트와 버그 테스트
학습 테스트: 프레임워크나 라이브러리 등에 대해서도 테스트 작성
버그 테스트: 코드 오류를 가장 잘 드러내줄 수 있는 테스트